-- Restrição do Jogo: Só funciona em Steal a Brainrot
if game.PlaceId ~= 109983668079237 then
    game:GetService("Players").LocalPlayer:Kick("Por favor entre no Steal a Brainrot")
    return
end

-- Proteção Anti-Kick e Anti-Crash
pcall(function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local mt = getrawmetatable(game)
    local gameShuttingDown = false

    game:BindToClose(function() gameShuttingDown = true end)
    
    if setreadonly then setreadonly(mt, false) end
    
    local oldNamecall = mt.__namecall
    local oldIndex = mt.__index
    
    mt.__namecall = newcclosure(function(self, ...)
        if gameShuttingDown then return oldNamecall(self, ...) end
        local method = getnamecallmethod()
        if typeof(method) == "string" and method:lower() == "kick" then
            warn("Tentativa de kick bloqueada via __namecall")
            return nil
        end
        return oldNamecall(self, ...)
    end)
    
    mt.__index = newcclosure(function(self, key)
        if gameShuttingDown then return oldIndex(self, key) end
        if typeof(key) == "string" then
            local lowered = key:lower()
            if lowered == "kick" then
                warn("Tentativa de kick bloqueada via __index")
                return function() end
            elseif (lowered == "breakjoints" or lowered == "destroy") then
                warn("Método destrutivo '" .. key .. "' bloqueado via __index")
                return function() end
            end
        end
        return oldIndex(self, key)
    end)
    
    if LocalPlayer then
        local originalKick = LocalPlayer.Kick
        LocalPlayer.Kick = function(self, ...)
            if not gameShuttingDown then
                warn("Tentativa de kick bloqueada via override .Kick")
                return nil
            end
            return originalKick(self, ...)
        end
    end
    
    local function protectCharacter(char)
        if not char then return end
        
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                local originalDestroy = part.Destroy
                part.Destroy = function(self, ...)
                    if not gameShuttingDown then
                        warn("Tentativa de destruir parte do personagem: " .. part.Name)
                        return nil
                    end
                    return originalDestroy(self, ...)
                end
            end
        end
        
        local hum = char:FindFirstChildWhichIsA("Humanoid")
        if hum then
            hum.BreakJointsOnDeath = false
        end
    end
    
    if LocalPlayer.Character then
        protectCharacter(LocalPlayer.Character)
    end
    
    LocalPlayer.CharacterAdded:Connect(protectCharacter)
    
    if setreadonly then setreadonly(mt, true) end
end)

-- Carregar RedzLib
local success, redzlib = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/tbao143/Library-ui/refs/heads/main/Redzhubui"))()
end)

if not success then
    warn("Falha ao carregar RedzLib:", redzlib)
    return
end

-- Criar Janela
local Window = redzlib:MakeWindow({
    Title = "Zeta Hub X Steal a Brainrot",
    SubTitle = "por SILENT",
    SaveFolder = "ZetaHubUniversal"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://100006760882280", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(0, 6) },
})

-- Serviços
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

-- Jogador e Referências
local LocalPlayer = Players.LocalPlayer
local character, humanoid
local markedLocation = nil
local baseBlockLocation = nil

local function updateReferences()
    character = LocalPlayer.Character
    humanoid = character and character:FindFirstChildOfClass("Humanoid") or nil
end

LocalPlayer.CharacterAdded:Connect(updateReferences)
LocalPlayer.CharacterRemoving:Connect(function()
    character = nil
    humanoid = nil
end)

updateReferences()

-- Aba Discord
local TabDiscord = Window:MakeTab({ Title = "Discord", Icon = "rbxassetid://84198990394879" })
TabDiscord:AddSection("Discord")
TabDiscord:AddDiscordInvite({
    Name = "Zeta Hub",
    Description = "Junte-se à comunidade",
    Logo = "rbxassetid://88800066762467",
    Invite = "https://discord.gg/pzrtAEDBbt"
})

-- Aba Segurança
local TabSecurity = Window:MakeTab({ Title = "Segurança", Icon = "rbxassetid://139126357881607" })
TabSecurity:AddSection("Ferramentas de Base")

TabSecurity:AddButton({
    Title = "Marcar Localização do Bloco de Base",
    Description = "Salva sua posição atual como referência do bloco de base",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if hrp then
            baseBlockLocation = hrp.Position
            print("Localização do bloco de base marcada em:", baseBlockLocation)
        else
            warn("HumanoidRootPart não encontrado")
        end
    end
})

TabSecurity:AddButton({
    Title = "Teleportar para Bloco de Base",
    Description = "Teleporta para a localização salva do bloco de base",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if hrp and baseBlockLocation then
            hrp.CFrame = CFrame.new(baseBlockLocation)
            print("Teleportado para o bloco de base")
        else
            warn("HumanoidRootPart ausente ou localização não marcada")
        end
    end
})

TabSecurity:AddButton({
    Title = "Teleportar para Sua Base Lateral",
    Description = "Teleporta para o PlotBlock da base atual em que você está",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local sideModel = nil
        for _, base in pairs(workspace:GetChildren()) do
            if base:IsA("Model") and base.Name:match("^%d+ Side$") then
                if character:IsDescendantOf(base) then
                    sideModel = base
                    break
                end
            end
        end
        
        if sideModel then
            local plot = sideModel:FindFirstChild("PlotBlock", true)
            if plot then
                hrp.CFrame = plot.CFrame + Vector3.new(0, 5, 0)
                print("Teleportado para PlotBlock:", sideModel.Name)
            else
                warn("PlotBlock não encontrado em", sideModel.Name)
            end
        else
            warn("Nenhuma base detectada")
        end
    end
})

-- Aba Principal
local TabMain = Window:MakeTab({ Title = "Principal", Icon = "rbxassetid://106319096400681" })
TabMain:AddSection("Movimento")

TabMain:AddButton({
    Title = "Marcar Localização",
    Description = "Salva sua posição atual para teleporte",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if hrp then
            markedLocation = hrp.Position
            print("Localização marcada em:", markedLocation)
        else
            warn("HumanoidRootPart não encontrado")
        end
    end
})

TabMain:AddButton({
    Title = "Teleporte Suave para Localização Marcada",
    Description = "Teleporte suave com passagem por paredes e imunidade a danos",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not hrp or not humanoid or not markedLocation then return end

        local originalHealth = humanoid.Health
        local immune = true
        
        local healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
            if immune and humanoid.Health < originalHealth then
                humanoid.Health = originalHealth
            end
        end)
        
        local affectedParts = {}
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                table.insert(affectedParts, { part = part, t = part.Transparency, c = part.CanCollide })
                part.Transparency = 1
                part.CanCollide = false
            elseif part:IsA("Decal") then
                part.Transparency = 1
            end
        end
        
        local removedWalls = {}
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name:lower():find("wall") then
                table.insert(removedWalls, { part = obj, t = obj.Transparency, c = obj.CanCollide })
                obj.Transparency = 1
                obj.CanCollide = false
            end
        end
        
        local dist = (hrp.Position - markedLocation).Magnitude
        local tweenInfo = TweenInfo.new(dist / 40, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, tweenInfo, { CFrame = CFrame.new(markedLocation + Vector3.new(0, 3, 0)) })
        
        tween:Play()
        tween.Completed:Connect(function()
            immune = false
            if healthConn then healthConn:Disconnect() end
            
            for _, data in ipairs(affectedParts) do
                if data.part and data.part.Parent then
                    data.part.Transparency = data.t
                    data.part.CanCollide = data.c
                end
            end
            
            for _, data in ipairs(removedWalls) do
                if data.part and data.part.Parent then
                    data.part.Transparency = data.t
                    data.part.CanCollide = data.c
                end
            end
        end)
    end
})

-- Anti-Ragdoll
local antiRagdollEnabled = false
local antiRagdollConnection

TabMain:AddSection("Anti-Ragdoll")
TabMain:AddToggle({
    Title = "Anti-Ragdoll",
    Description = "Previne que seu personagem vire um ragdoll",
    Default = false,
    Callback = function(state)
        antiRagdollEnabled = state
        if state then
            warn("Anti-Ragdoll ativado")
            antiRagdollConnection = RunService.Heartbeat:Connect(function()
                updateReferences()
                if not character then return end
                
                for _, limb in ipairs({"Left Arm", "Right Arm", "Left Leg", "Right Leg", "Head", "Torso", "UpperTorso", "LowerTorso"}) do
                    local part = character:FindFirstChild(limb)
                    if part then
                        for _, c in ipairs(part:GetChildren()) do
                            if c:IsA("BallSocketConstraint") or c:IsA("HingeConstraint") then
                                c:Destroy()
                            end
                        end
                    end
                end
                
                for _, joint in ipairs(character:GetDescendants()) do
                    if joint:IsA("Motor6D") then
                        joint.Enabled = true
                    end
                end
            end)
        else
            warn("Anti-Ragdoll desativado")
            if antiRagdollConnection then
                antiRagdollConnection:Disconnect()
                antiRagdollConnection = nil
            end
        end
    end
})

-- Aba Funções
local TabFunctions = Window:MakeTab({ Title = "Funções", Icon = "rbxassetid://103306413269388" })

-- Pulo Infinito
local infiniteJumpEnabled = false
local jumpConnection

local function handleJump()
    updateReferences()
    if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

TabFunctions:AddToggle({
    Title = "Pulo Infinito",
    Description = "Permite que você pule infinitamente no ar",
    Default = false,
    Callback = function(state)
        infiniteJumpEnabled = state
        if state then
            warn("Pulo Infinito ativado")
            if jumpConnection then jumpConnection:Disconnect() end
            jumpConnection = UserInputService.JumpRequest:Connect(handleJump)
            
            LocalPlayer.CharacterAdded:Connect(function()
                updateReferences()
                if infiniteJumpEnabled then
                    if jumpConnection then jumpConnection:Disconnect() end
                    jumpConnection = UserInputService.JumpRequest:Connect(handleJump)
                end
            end)
        else
            warn("Pulo Infinito desativado")
            if jumpConnection then
                jumpConnection:Disconnect()
                jumpConnection = nil
            end
        end
    end
})

-- NoClip
local noClipEnabled = false
local noClipConnection

local function noclipLoop()
    updateReferences()
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

TabFunctions:AddToggle({
    Title = "NoClip",
    Description = "Permite que você atravesse paredes",
    Default = false,
    Callback = function(state)
        noClipEnabled = state
        if state then
            warn("NoClip ativado")
            noClipConnection = RunService.Stepped:Connect(noclipLoop)
        else
            warn("NoClip desativado")
            if noClipConnection then
                noClipConnection:Disconnect()
                noClipConnection = nil
            end
        end
    end
})

-- ESP de Jogadores (Persistente entre mortes)
local espEnabled = false
local espFolders = {}
local espConnections = {}

local function createESP(player)
    if player == Players.LocalPlayer then return end

    local function setup()
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
        
        -- Remover ESP existente
        if espFolders[player] then
            espFolders[player]:Destroy()
        end
        if espConnections[player] then
            for _, conn in pairs(espConnections[player]) do
                pcall(function() conn:Disconnect() end)
            end
            espConnections[player] = {}
        end
        
        local folder = Instance.new("Folder")
        folder.Name = "ESP" .. player.Name
        folder.Parent = workspace
        espFolders[player] = folder
        
        local highlight = Instance.new("Highlight")
        highlight.Adornee = player.Character
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.Parent = folder
        
        local billboard = Instance.new("BillboardGui")
        billboard.Adornee = player.Character:FindFirstChild("HumanoidRootPart")
        billboard.Size = UDim2.new(0, 200, 0, 40)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = 1000
        billboard.Parent = folder
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextStrokeTransparency = 0.5
        textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        textLabel.TextSize = 14
        textLabel.Font = Enum.Font.GothamBold
        textLabel.Text = player.Name
        textLabel.TextColor3 = Color3.new(1, 1, 1)
        textLabel.Parent = billboard
        
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local function updateText()
                textLabel.Text = string.format("%s [%d/%d]", player.Name, math.floor(humanoid.Health), math.floor(humanoid.MaxHealth))
            end
            updateText()
            
            if not espConnections[player] then
                espConnections[player] = {}
            end
            espConnections[player].healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(updateText)
        end
        
        if not espConnections[player] then
            espConnections[player] = {}
        end
        espConnections[player].renderConn = RunService.RenderStepped:Connect(function()
            local hue = tick() % 5 / 5
            local color = Color3.fromHSV(hue, 1, 1)
            textLabel.TextColor3 = color
            highlight.FillColor = color
            highlight.OutlineColor = color
        end)
    end
    
    setup()
    
    -- Garantir que ESP persista entre respawns de personagem
    if not espConnections[player] then
        espConnections[player] = {}
    end
    espConnections[player].charAdded = player.CharacterAdded:Connect(function()
        task.wait(0.5)
        if espEnabled then
            setup()
        end
    end)
end

local function updateESP()
    for player, folder in pairs(espFolders) do
        if folder then folder:Destroy() end
    end
    for player, conns in pairs(espConnections) do
        for _, conn in pairs(conns) do
            pcall(function() conn:Disconnect() end)
        end
    end
    espFolders = {}
    espConnections = {}

    if espEnabled then
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                createESP(player)
            end
        end
    end
end

-- ESP permanece ativo após morte do jogador local
local espPlayerAddedConnection
local espLocalPlayerRespawnConnection

TabFunctions:AddToggle({
    Title = "ESP de Jogadores",
    Description = "Destaca jogadores com RGB + nome e vida (Persistente)",
    Default = false,
    Callback = function(state)
        espEnabled = state
        if state then
            warn("ESP ativado")
            updateESP()
            
            -- Lidar com novos jogadores entrando
            if espPlayerAddedConnection then espPlayerAddedConnection:Disconnect() end
            espPlayerAddedConnection = Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function()
                    task.wait(0.5)
                    if espEnabled then
                        createESP(player)
                    end
                end)
            end)
            
            -- Garantir que ESP permaneça ativo após respawns do jogador local
            if espLocalPlayerRespawnConnection then espLocalPlayerRespawnConnection:Disconnect() end
            espLocalPlayerRespawnConnection = LocalPlayer.CharacterAdded:Connect(function()
                task.wait(1)
                if espEnabled then
                    updateESP()
                end
            end)
        else
            warn("ESP desativado")
            updateESP()
            if espPlayerAddedConnection then espPlayerAddedConnection:Disconnect() end
            if espLocalPlayerRespawnConnection then espLocalPlayerRespawnConnection:Disconnect() end
        end
    end
})

-- GodMode aprimorado com melhor proteção
local godModeEnabled = false
local godModeConnection
local godModeHealthConnection

TabFunctions:AddToggle({
    Title = "GodMode",
    Description = "God mode avançado com múltiplas camadas de proteção",
    Default = false,
    Callback = function(state)
        godModeEnabled = state
        if state then
            warn("GodMode ativado")
            
            local function setupGodMode()
                updateReferences()
                if not humanoid then return end
                
                -- Armazenar vida máxima original
                local originalMaxHealth = humanoid.MaxHealth
                
                -- Monitoramento de vida
                if godModeHealthConnection then godModeHealthConnection:Disconnect() end
                godModeHealthConnection = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                    if godModeEnabled and humanoid.Health < originalMaxHealth then
                        humanoid.Health = originalMaxHealth
                    end
                end)
                
                -- Prevenir estado de morte
                local stateConnection = humanoid:GetPropertyChangedSignal("PlatformStand"):Connect(function()
                    if godModeEnabled then
                        humanoid.PlatformStand = false
                    end
                end)
                
                -- Monitorar morte e restaurar
                local deathConnection = humanoid.Died:Connect(function()
                    if godModeEnabled then
                        task.wait(0.1)
                        if humanoid and humanoid.Parent then
                            humanoid:ChangeState(Enum.HumanoidStateType.Running)
                            humanoid.Health = originalMaxHealth
                        end
                    end
                end)
                
                -- Armazenar conexões para limpeza
                if not espConnections.godMode then
                    espConnections.godMode = {}
                end
                espConnections.godMode.health = godModeHealthConnection
                espConnections.godMode.state = stateConnection
                espConnections.godMode.death = deathConnection
            end
            
            -- Loop principal do godmode
            godModeConnection = RunService.Heartbeat:Connect(function()
                updateReferences()
                if not character or not humanoid then return end
                
                -- Forçar vida para o máximo
                if humanoid.Health < humanoid.MaxHealth then
                    humanoid.Health = humanoid.MaxHealth
                end
                
                -- Prevenir estado de morte
                if humanoid:GetState() == Enum.HumanoidStateType.Dead then
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                    humanoid.Health = humanoid.MaxHealth
                end
                
                -- Remover efeitos de dano
                for _, part in ipairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        -- Remover fogo, fumaça ou outros efeitos de dano
                        for _, effect in ipairs(part:GetChildren()) do
                            if effect:IsA("Fire") or effect:IsA("Smoke") or effect:IsA("Sparkles") then
                                effect:Destroy()
                            end
                        end
                    end
                end
            end)
            
            -- Configurar para personagem atual
            setupGodMode()
            
            -- Re-configurar ao respawnar personagem
            LocalPlayer.CharacterAdded:Connect(function()
                task.wait(0.5)
                if godModeEnabled then
                    setupGodMode()
                end
            end)
            
        else
            warn("GodMode desativado")
            if godModeConnection then
                godModeConnection:Disconnect()
                godModeConnection = nil
            end
            if godModeHealthConnection then
                godModeHealthConnection:Disconnect()
                godModeHealthConnection = nil
            end
            if espConnections.godMode then
                for _, conn in pairs(espConnections.godMode) do
                    pcall(function() conn:Disconnect() end)
                end
                espConnections.godMode = nil
            end
        end
    end
})

-- Limpeza ao finalizar o script
game:BindToClose(function()
    for player, folder in pairs(espFolders) do
        if folder then folder:Destroy() end
    end
    for player, conns in pairs(espConnections) do
        for _, conn in pairs(conns) do
            pcall(function() conn:Disconnect() end)
        end
    end
end)
